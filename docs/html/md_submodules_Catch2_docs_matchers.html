<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tsunami Reis: matchers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tsunami Reis
   </div>
   <div id="projectbrief">Tsunami Simulation Justus Dre√üler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">matchers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="top"></a> </p>
<h1><a class="anchor" id="autotoc_md164"></a>
Matchers</h1>
<p>Matchers are an alternative way to do assertions which are easily extensible and composable. This makes them well suited to use with more complex types (such as collections) or your own custom types. Matchers were first popularised by the <a href="https://en.wikipedia.org/wiki/Hamcrest">Hamcrest</a> family of frameworks.</p>
<h2><a class="anchor" id="autotoc_md165"></a>
In use</h2>
<p>Matchers are introduced with the <code>REQUIRE_THAT</code> or <code>CHECK_THAT</code> macros, which take two arguments. The first argument is the thing (object or value) under test. The second part is a match <em>expression</em>, which consists of either a single matcher or one or more matchers combined using <code>&amp;&amp;</code>, <code>||</code> or <code>!</code> operators.</p>
<p>For example, to assert that a string ends with a certain substring:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">using Catch::Matchers::EndsWith; // or Catch::EndsWith</div>
<div class="line">std::string str = getStringFromSomewhere();</div>
<div class="line">REQUIRE_THAT( str, EndsWith( &quot;as a service&quot; ) );</div>
</div><!-- fragment --><p>The matcher objects can take multiple arguments, allowing more fine tuning. The built-in string matchers, for example, take a second argument specifying whether the comparison is case sensitive or not:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">REQUIRE_THAT( str, EndsWith( &quot;as a service&quot;, Catch::CaseSensitive::No ) );</div>
</div><!-- fragment --><p>And matchers can be combined:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">REQUIRE_THAT( str,</div>
<div class="line">    EndsWith( &quot;as a service&quot; ) ||</div>
<div class="line">    (StartsWith( &quot;Big data&quot; ) &amp;&amp; !Contains( &quot;web scale&quot; ) ) );</div>
</div><!-- fragment --><p><em>The combining operators do not take ownership of the matcher objects. This means that if you store the combined object, you have to ensure that the matcher objects outlive its last use. What this means is that code like this leads to a use-after-free and (hopefully) a crash:</em></p>
<div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;Bugs, bugs, bugs&quot;</span>, <span class="stringliteral">&quot;[Bug]&quot;</span>){</div>
<div class="line">    std::string str = <span class="stringliteral">&quot;Bugs as a service&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> match_expression = Catch::EndsWith( <span class="stringliteral">&quot;as a service&quot;</span> ) ||</div>
<div class="line">        (Catch::StartsWith( <span class="stringliteral">&quot;Big data&quot;</span> ) &amp;&amp; !Catch::Contains( <span class="stringliteral">&quot;web scale&quot;</span> ) );</div>
<div class="line">    REQUIRE_THAT(str, match_expression);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md166"></a>
Built in matchers</h2>
<p>Catch2 provides some matchers by default. They can be found in the <code>Catch::Matchers::foo</code> namespace and are imported into the <code>Catch</code> namespace as well.</p>
<p>There are two parts to each of the built-in matchers, the matcher type itself and a helper function that provides template argument deduction when creating templated matchers. As an example, the matcher for checking that two instances of <code>std::vector</code> are identical is <code>EqualsMatcher&lt;T&gt;</code>, but the user is expected to use the <code>Equals</code> helper function instead.</p>
<h3><a class="anchor" id="autotoc_md167"></a>
String matchers</h3>
<p>The string matchers are <code>StartsWith</code>, <code>EndsWith</code>, <code>Contains</code>, <code>Equals</code> and <code>Matches</code>. The first four match a literal (sub)string against a result, while <code>Matches</code> takes and matches an ECMAScript regex. Do note that <code>Matches</code> matches the string as a whole, meaning that "abc" will not match against "abcd", but "abc.*" will.</p>
<p>Each of the provided <code>std::string</code> matchers also takes an optional second argument, that decides case sensitivity (by-default, they are case sensitive).</p>
<h3><a class="anchor" id="autotoc_md168"></a>
Vector matchers</h3>
<p>Catch2 currently provides 5 built-in matchers that work on <code>std::vector</code>. These are</p>
<ul>
<li><code>Contains</code> which checks whether a specified vector is present in the result</li>
<li><code>VectorContains</code> which checks whether a specified element is present in the result</li>
<li><code>Equals</code> which checks whether the result is exactly equal (order matters) to a specific vector</li>
<li><code>UnorderedEquals</code> which checks whether the result is equal to a specific vector under a permutation</li>
<li><code>Approx</code> which checks whether the result is "approx-equal" (order matters, but comparison is done via <code>Approx</code>) to a specific vector <blockquote class="doxtable">
<p>Approx matcher was <a href="https://github.com/catchorg/Catch2/issues/1499">introduced</a> in Catch 2.7.2. </p>
</blockquote>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md169"></a>
Floating point matchers</h3>
<p>Catch2 provides 3 matchers for working with floating point numbers. These are <code>WithinAbsMatcher</code>, <code>WithinUlpsMatcher</code> and <code>WithinRelMatcher</code>.</p>
<p>The <code>WithinAbsMatcher</code> matcher accepts floating point numbers that are within a certain distance of target. It should be constructed with the <code>WithinAbs(double target, double margin)</code> helper.</p>
<p>The <code>WithinUlpsMatcher</code> matcher accepts floating point numbers that are within a certain number of <a href="https://en.wikipedia.org/wiki/Unit_in_the_last_place">ULPs</a> of the target. Because ULP comparisons need to be done differently for <code>float</code>s and for <code>double</code>s, there are two overloads of the helpers for this matcher, <code>WithinULP(float target, int64_t ULPs)</code>, and <code>WithinULP(double target, int64_t ULPs)</code>.</p>
<p>The <code>WithinRelMatcher</code> matcher accepts floating point numbers that are <em>approximately equal</em> with the target number with some specific tolerance. In other words, it checks that <code>|lhs - rhs| &lt;= epsilon * max(|lhs|, |rhs|)</code>, with special casing for <code>INFINITY</code> and <code>NaN</code>. There are <em>4</em> overloads of the helpers for this matcher, <code>WithinRel(double target, double margin)</code>, <code>WithinRel(float target, float margin)</code>, <code>WithinRel(double target)</code>, and <code>WithinRel(float target)</code>. The latter two provide a default epsilon of machine epsilon * 100.</p>
<blockquote class="doxtable">
<p><code>WithinRel</code> matcher was introduced in Catch 2.10.0 </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md170"></a>
Generic matchers</h3>
<p>Catch also aims to provide a set of generic matchers. Currently this set contains only a matcher that takes arbitrary callable predicate and applies it onto the provided object.</p>
<p>Because of type inference limitations, the argument type of the predicate has to be provided explicitly. Example: </p><div class="fragment"><div class="line">REQUIRE_THAT(<span class="stringliteral">&quot;Hello olleH&quot;</span>,</div>
<div class="line">             Predicate&lt;std::string&gt;(</div>
<div class="line">                 [] (std::string <span class="keyword">const</span>&amp; str) -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> str.front() == str.back(); },</div>
<div class="line">                 <span class="stringliteral">&quot;First and last character should be equal&quot;</span>)</div>
<div class="line">);</div>
</div><!-- fragment --><p>The second argument is an optional description of the predicate, and is used only during reporting of the result.</p>
<h3><a class="anchor" id="autotoc_md171"></a>
Exception matchers</h3>
<p>Catch2 also provides an exception matcher that can be used to verify that an exception's message exactly matches desired string. The matcher is <code>ExceptionMessageMatcher</code>, and we also provide a helper function <code>Message</code>.</p>
<p>The matched exception must publicly derive from <code>std::exception</code> and the message matching is done <em>exactly</em>, including case.</p>
<blockquote class="doxtable">
<p><code>ExceptionMessageMatcher</code> was introduced in Catch 2.10.0 </p>
</blockquote>
<p>Example use: </p><div class="fragment"><div class="line">REQUIRE_THROWS_MATCHES(throwsDerivedException(),  DerivedException,  Message(<span class="stringliteral">&quot;DerivedException::what&quot;</span>));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md172"></a>
Custom matchers</h2>
<p>It's easy to provide your own matchers to extend Catch or just to work with your own types.</p>
<p>You need to provide two things:</p><ol type="1">
<li>A matcher class, derived from <code>Catch::MatcherBase&lt;T&gt;</code> - where <code>T</code> is the type being tested. The constructor takes and stores any arguments needed (e.g. something to compare against) and you must override two methods: <code>match()</code> and <code>describe()</code>.</li>
<li>A simple builder function. This is what is actually called from the test code and allows overloading.</li>
</ol>
<p>Here's an example for asserting that an integer falls within a given range (note that it is all inline for the sake of keeping the example short):</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// The matcher class</div>
<div class="line">class IntRange : public Catch::MatcherBase&lt;int&gt; {</div>
<div class="line">    int m_begin, m_end;</div>
<div class="line">public:</div>
<div class="line">    IntRange( int begin, int end ) : m_begin( begin ), m_end( end ) {}</div>
<div class="line"> </div>
<div class="line">    // Performs the test for this matcher</div>
<div class="line">    bool match( int const&amp; i ) const override {</div>
<div class="line">        return i &gt;= m_begin &amp;&amp; i &lt;= m_end;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // Produces a string describing what this matcher does. It should</div>
<div class="line">    // include any provided data (the begin/ end in this case) and</div>
<div class="line">    // be written as if it were stating a fact (in the output it will be</div>
<div class="line">    // preceded by the value under test).</div>
<div class="line">    virtual std::string describe() const override {</div>
<div class="line">        std::ostringstream ss;</div>
<div class="line">        ss &lt;&lt; &quot;is between &quot; &lt;&lt; m_begin &lt;&lt; &quot; and &quot; &lt;&lt; m_end;</div>
<div class="line">        return ss.str();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// The builder function</div>
<div class="line">inline IntRange IsBetween( int begin, int end ) {</div>
<div class="line">    return IntRange( begin, end );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// ...</div>
<div class="line"> </div>
<div class="line">// Usage</div>
<div class="line">TEST_CASE(&quot;Integers are within a range&quot;)</div>
<div class="line">{</div>
<div class="line">    CHECK_THAT( 3, IsBetween( 1, 10 ) );</div>
<div class="line">    CHECK_THAT( 100, IsBetween( 1, 10 ) );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Running this test gives the following in the console:</p>
<div class="fragment"><div class="line">/**/TestFile.cpp:123: FAILED:</div>
<div class="line">  CHECK_THAT( 100, IsBetween( 1, 10 ) )</div>
<div class="line">with expansion:</div>
<div class="line">  100 is between 1 and 10</div>
</div><!-- fragment --><hr  />
<p><a href="Readme.md#top">Home</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
