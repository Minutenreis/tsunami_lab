\label{_top}%
 \hypertarget{md_submodules_Catch2_docs_test-fixtures_autotoc_md474}{}\doxysection{Test fixtures}\label{md_submodules_Catch2_docs_test-fixtures_autotoc_md474}
\hypertarget{md_submodules_Catch2_docs_test-fixtures_autotoc_md475}{}\doxysubsection{Defining test fixtures}\label{md_submodules_Catch2_docs_test-fixtures_autotoc_md475}
Although Catch allows you to group tests together as sections within a test case, it can still be convenient, sometimes, to group them using a more traditional test fixture. Catch fully supports this too. You define the test fixture as a simple structure\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{class UniqueTestsFixture \{}
\DoxyCodeLine{  private:}
\DoxyCodeLine{   static int uniqueID;}
\DoxyCodeLine{  protected:}
\DoxyCodeLine{   DBConnection conn;}
\DoxyCodeLine{  public:}
\DoxyCodeLine{   UniqueTestsFixture() : conn(DBConnection::createConnection("myDB")) \{}
\DoxyCodeLine{   \}}
\DoxyCodeLine{  protected:}
\DoxyCodeLine{   int getID() \{}
\DoxyCodeLine{     return ++uniqueID;}
\DoxyCodeLine{   \}}
\DoxyCodeLine{ \};}
\DoxyCodeLine{}
\DoxyCodeLine{ int UniqueTestsFixture::uniqueID = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{ TEST\_CASE\_METHOD(UniqueTestsFixture, "Create Employee/No Name", "[create]") \{}
\DoxyCodeLine{   REQUIRE\_THROWS(conn.executeSQL("INSERT INTO employee (id, name) VALUES (?, ?)", getID(), ""));}
\DoxyCodeLine{ \}}
\DoxyCodeLine{ TEST\_CASE\_METHOD(UniqueTestsFixture, "Create Employee/Normal", "[create]") \{}
\DoxyCodeLine{   REQUIRE(conn.executeSQL("INSERT INTO employee (id, name) VALUES (?, ?)", getID(), "Joe Bloggs"));}
\DoxyCodeLine{ \}}
\end{DoxyCode}


The two test cases here will create uniquely-\/named derived classes of \mbox{\hyperlink{classUniqueTestsFixture}{Unique\+Tests\+Fixture}} and thus can access the {\ttfamily get\+I\+D()} protected method and {\ttfamily conn} member variables. This ensures that both the test cases are able to create a \mbox{\hyperlink{classDBConnection}{D\+B\+Connection}} using the same method (D\+RY principle) and that any ID\textquotesingle{}s created are unique such that the order that tests are executed does not matter.

Catch2 also provides {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD} and {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+P\+R\+O\+D\+U\+C\+T\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD} that can be used together with templated fixtures and templated template fixtures to perform tests for multiple different types. Unlike {\ttfamily T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD}, {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD} and {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+P\+R\+O\+D\+U\+C\+T\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD} do require the tag specification to be non-\/empty, as it is followed by further macro arguments.

Also note that, because of limitations of the C++ preprocessor, if you want to specify a type with multiple template parameters, you need to enclose it in parentheses, e.\+g. {\ttfamily std\+::map$<$int, std\+::string$>$} needs to be passed as {\ttfamily (std\+::map$<$int, std\+::string$>$)}. In the case of {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+P\+R\+O\+D\+U\+C\+T\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD}, if a member of the type list should consist of more than single type, it needs to be enclosed in another pair of parentheses, e.\+g. {\ttfamily (std\+::map, std\+::pair)} and {\ttfamily ((int, float), (char, double))}.

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}< \textcolor{keyword}{typename} T >}
\DoxyCodeLine{\textcolor{keyword}{struct }Template\_Fixture \{}
\DoxyCodeLine{    Template\_Fixture(): m\_a(1) \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{    T m\_a;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{TEMPLATE\_TEST\_CASE\_METHOD(Template\_Fixture,\textcolor{stringliteral}{"A TEMPLATE\_TEST\_CASE\_METHOD based test run that succeeds"}, \textcolor{stringliteral}{"[class][template]"}, \textcolor{keywordtype}{int}, \textcolor{keywordtype}{float}, \textcolor{keywordtype}{double}) \{}
\DoxyCodeLine{    REQUIRE( Template\_Fixture<TestType>::m\_a == 1 );}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\textcolor{keyword}{struct }Template\_Template\_Fixture \{}
\DoxyCodeLine{    Template\_Template\_Fixture() \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{    T m\_a;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\textcolor{keyword}{struct }Foo\_class \{}
\DoxyCodeLine{    \textcolor{keywordtype}{size\_t} size() \{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD(Template\_Template\_Fixture, \textcolor{stringliteral}{"A TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD based test succeeds"}, \textcolor{stringliteral}{"[class][template]"}, (Foo\_class, std::vector), \textcolor{keywordtype}{int}) \{}
\DoxyCodeLine{    REQUIRE( Template\_Template\_Fixture<TestType>::m\_a.size() == 0 );}
\DoxyCodeLine{\}}
\end{DoxyCode}


{\itshape While there is an upper limit on the number of types you can specify in single {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD} or {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+P\+R\+O\+D\+U\+C\+T\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD}, the limit is very high and should not be encountered in practice.}\hypertarget{md_submodules_Catch2_docs_test-fixtures_autotoc_md476}{}\doxysubsection{Signature-\/based parametrised test fixtures}\label{md_submodules_Catch2_docs_test-fixtures_autotoc_md476}
\begin{quote}
\href{https://github.com/catchorg/Catch2/issues/1609}{\texttt{ Introduced}} in Catch 2.\+8.\+0. \end{quote}


Catch2 also provides {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+O\+D\+\_\+\+S\+IG} and {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+P\+R\+O\+D\+U\+C\+T\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+O\+D\+\_\+\+S\+IG} to support fixtures using non-\/type template parameters. These test cases work similar to {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD} and {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+P\+R\+O\+D\+U\+C\+T\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD}, with additional positional argument for \href{test-cases-and-sections.md\#signature-based-parametrised-test-cases}{\texttt{ signature}}.

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keywordtype}{int} V>}
\DoxyCodeLine{\textcolor{keyword}{struct }Nttp\_Fixture\{}
\DoxyCodeLine{    \textcolor{keywordtype}{int} value = V;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{TEMPLATE\_TEST\_CASE\_METHOD\_SIG(Nttp\_Fixture, \textcolor{stringliteral}{"A TEMPLATE\_TEST\_CASE\_METHOD\_SIG based test run that succeeds"}, \textcolor{stringliteral}{"[class][template][nttp]"},((\textcolor{keywordtype}{int} V), V), 1, 3, 6) \{}
\DoxyCodeLine{    REQUIRE(Nttp\_Fixture<V>::value > 0);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\textcolor{keyword}{struct }Template\_Fixture\_2 \{}
\DoxyCodeLine{    Template\_Fixture\_2() \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{    T m\_a;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}< \textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} V>}
\DoxyCodeLine{\textcolor{keyword}{struct }Template\_Foo\_2 \{}
\DoxyCodeLine{    \textcolor{keywordtype}{size\_t} size() \{ \textcolor{keywordflow}{return} V; \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG(Template\_Fixture\_2, \textcolor{stringliteral}{"A TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG based test run that succeeds"}, \textcolor{stringliteral}{"[class][template][product][nttp]"}, ((\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} \mbox{\hyperlink{structS}{S}}), T, \mbox{\hyperlink{structS}{S}}),(std::array, Template\_Foo\_2), ((\textcolor{keywordtype}{int},2), (\textcolor{keywordtype}{float},6)))}
\DoxyCodeLine{\{}
\DoxyCodeLine{    REQUIRE(Template\_Fixture\_2<TestType>\{\}.m\_a.size() >= 2);}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{md_submodules_Catch2_docs_test-fixtures_autotoc_md477}{}\doxysubsection{Template fixtures with types specified in template type lists}\label{md_submodules_Catch2_docs_test-fixtures_autotoc_md477}
Catch2 also provides {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+L\+I\+S\+T\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD} to support template fixtures with types specified in template type lists like {\ttfamily std\+::tuple}, {\ttfamily boost\+::mpl\+::list} or {\ttfamily boost\+::mp11\+::mp\+\_\+list}. This test case works the same as {\ttfamily T\+E\+M\+P\+L\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+M\+E\+T\+H\+OD}, only difference is the source of types. This allows you to reuse the template type list in multiple test cases.

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using} MyTypes = std::tuple<int, char, double>;}
\DoxyCodeLine{TEMPLATE\_LIST\_TEST\_CASE\_METHOD(Template\_Fixture, \textcolor{stringliteral}{"Template test case method with test types specified inside std::tuple"}, \textcolor{stringliteral}{"[class][template][list]"}, MyTypes)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    REQUIRE( Template\_Fixture<TestType>::m\_a == 1 );}
\DoxyCodeLine{\}}
\end{DoxyCode}


\DoxyHorRuler{0}


\href{Readme.md\#top}{\texttt{ Home}} 